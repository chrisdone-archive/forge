{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE StandaloneDeriving #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE DeriveFunctor #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE LambdaCase #-}

-- | Generate a form.
--
-- Forms generate views and they generate results. They are coupled
-- together. This type represents that coupling.

module Forge.Generate
  ( generate
  , view
  ) where

import           Data.Bifunctor
import           Data.Map.Strict (Map)
import qualified Data.Map.Strict as M
import           Data.Validation
import           Forge.Internal.Types
import           Forge.Verify

-- | Generate a form in the given action context.
generate ::
     forall index m a.
     ( m ~ Action index
     , Monad m
     , FormError index
     , Monoid (View index)
     , FormField index
     )
  => Map Key Input
  -- ^ The inputs to your form.
  -> VerifiedForm index a
  -- ^ The description of your form.
  -> m (Generated index a)
  -- ^ The generated resut of the view and any value or errors.
generate inputs = go PathBegin . unVerifiedForm
  where
    go :: forall x. (Path -> Path) -> Form index x -> m (Generated index x)
    go path =
      \case
        ValueForm m -> fmap pure m
        MapValueForm f form -> fmap (fmap f) (go (path . InMapValue) form)
        ApValueForm f x ->
          (<*>) <$> go (path . InApLeft) f <*> go (path . InApRight) x
        ViewForm m -> pure (pureView m)
        FieldForm name m -> do
          field <- m
          let key =
                case name of
                  DynamicFieldName -> pathToKey (path PathEnd)
                  StaticFieldName text -> Key text
              generatedView = pure (viewField @index key field)
          case M.lookup key inputs of
            Nothing ->
              pure
                (Generated
                   { generatedValue =
                       Failure (pure (missingInputError @index key))
                   , generatedView
                   })
            Just input ->
              case parseFieldInput @index key field input of
                Left errorIndexed ->
                  pure
                    (Generated
                       { generatedValue = Failure (pure errorIndexed)
                       , generatedView
                       })
                Right a ->
                  pure (Generated {generatedView, generatedValue = pure a})
        ParseForm f form -> do
          generated@Generated {generatedView} <- go (path . InParse) form
          case generatedValue generated of
            Success a -> do
              result <- f a
              case result of
                Left err ->
                  pure
                    (Generated
                       { generatedView =
                           viewWithError (Just err) (path . InParse) form
                       , generatedValue = Failure [err]
                       })
                Right r ->
                  pure (Generated {generatedView, generatedValue = Success r})
            Failure errs -> do
              pure (Generated {generatedView, generatedValue = Failure errs})
        FloorForm _ form -> go (path . InParse) form
        CeilingForm f form -> do
          generated@Generated {generatedView} <- go (path . InParse) form
          let (generatedView', errs') =
                f
                  (validation id (const []) (generatedValue generated))
                  generatedView
          pure
            (Generated
               { generatedView = generatedView'
               , generatedValue = first (const errs') (generatedValue generated)
               })
    pureView v = Generated {generatedView = v, generatedValue = pure ()}

-- | Convert a path to a rendered key.
pathToKey :: Path -> Key
pathToKey = Key . go
  where
    go =
      \case
        PathBegin path -> "/" <> go path
        InMapValue path -> "m/" <> go path
        InApLeft path -> "l/" <> go path
        InApRight path -> "r/" <> go path
        InParse path -> "p/" <> go path
        PathEnd -> ""

-- | View a form in the given action context.
view ::
     forall index f a.
     ( f ~ Action index
     , Monoid (View index)
     , Functor f
     , Applicative f
     , FormField index
     )
  => VerifiedForm index a
  -- ^ The description of your form.
  -> f (View index)
  -- ^ The view of the form, no validations.
view = viewWithError Nothing PathBegin . unVerifiedForm

-- | View the form with the given error from above.
viewWithError ::
     forall index f a.
     ( f ~ Action index
     , Monoid (View index)
     , Functor f
     , Applicative f
     , FormField index
     )
  => Maybe (Error index)
  -- ^ Errors generated by an above validation.
  -> (Path -> Path)
  -- ^ Starting path.
  -> Form index a
  -- ^ The description of your form.
  -> f (View index)
  -- ^ The view of the form, no validations.
viewWithError = go
  where
    go ::
         forall x.
         Maybe (Error index)
      -> (Path -> Path)
      -> Form index x
      -> f (View index)
    go errs path =
      \case
        ValueForm _ -> pure mempty
        MapValueForm _ form -> go errs (path . InMapValue) form
        CeilingForm _ form -> go errs (path . InParse) form
        ApValueForm f x ->
          (<>) <$> go errs (path . InApLeft) f <*> go errs (path . InApRight) x
        ViewForm m -> m
        FieldForm name m -> fmap (viewField @index key) m
          where key =
                  case name of
                    DynamicFieldName -> pathToKey (path PathEnd)
                    StaticFieldName text -> Key text
        ParseForm _ form -> go errs (path . InParse) form
        FloorForm f form ->
          let (view', errs') = f errs (go errs' (path . InParse) form)
           in view'
